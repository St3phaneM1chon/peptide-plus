# Business Logic & E-Commerce Audit Report
## peptide-plus / BioCycle Peptides
### Date: 2026-02-19
### Auditor: Claude Opus 4.6

---

## Executive Summary

Audited the complete e-commerce business logic spanning payment flows (Stripe + PayPal), inventory management, promo codes, gift cards, order lifecycle, pricing, user data (GDPR), loyalty/referral programs, and shipping calculations. **Found 22 issues** ranging from critical financial vulnerabilities to medium-severity data integrity gaps.

The project has strong foundations -- server-side price validation, webhook signature verification, idempotence checks, and inventory reservation with TTL. However, several race conditions, missing validations, and incomplete implementations create exploitable gaps.

---

## Findings

---

### E-01: Order Number Generation Has Race Condition (Concurrent Webhooks Can Collide)
- **Severity**: CRITICAL
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/webhook/route.ts` (lines 191-198)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/paypal/capture/route.ts` (lines 117-125)
- **Description**: Order numbers are generated by reading the last order number (`findFirst` + `orderBy desc`), incrementing it, and using it in a `$transaction`. However, the read happens OUTSIDE the transaction in the Stripe webhook (lines 191-198), meaning two concurrent webhook calls can read the same `lastNum` and generate duplicate order numbers. The `orderNumber` field has a `@unique` constraint in Prisma, so one insert would crash -- causing the order to fail silently.
- **Impact**: Under concurrent load (e.g., two Stripe webhooks arriving within milliseconds), one order will fail to create, resulting in a paid customer with no order record. Financial loss and customer support burden.
- **Fix**: Move the order number generation INSIDE the `$transaction` block, or use a PostgreSQL sequence (`nextval()`) via raw SQL. Example:
  ```typescript
  const order = await prisma.$transaction(async (tx) => {
    const lastOrder = await tx.order.findFirst({
      where: { orderNumber: { startsWith: prefix } },
      orderBy: { orderNumber: 'desc' },
      select: { orderNumber: true },
    });
    const lastNum = lastOrder ? parseInt(lastOrder.orderNumber.replace(prefix, ''), 10) : 0;
    const orderNumber = `${prefix}${String(lastNum + 1).padStart(6, '0')}`;
    // ... create order with this number
  });
  ```

---

### E-02: PayPal Capture Route Trusts Client-Sent Tax and Shipping Amounts
- **Severity**: CRITICAL
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/paypal/capture/route.ts` (lines 38-49, 111-114)
- **Description**: The PayPal capture endpoint receives `taxBreakdown`, `shippingCost`, `subtotal`, and `promoDiscount` from the client request body and stores them directly into the order without server-side recalculation. While `item.price` is verified from the database (lines 79-98), the tax, shipping, and promo discount values are accepted as-is. A malicious client could send `taxBreakdown: {tps: 0, tvq: 0, tvh: 0}` and `shippingCost: 0` to reduce their order total while the PayPal captured amount (which IS used as the total) would also be the reduced amount since PayPal create-order also does not add taxes/shipping.
- **Impact**: Tax evasion. The order record shows $0 in taxes, and accounting entries would record incorrect tax liabilities. Also, the PayPal create-order route (lines 100-101) sets `serverTotal = serverSubtotal` with a comment "Shipping/taxes handled by PayPal or added separately" -- but they are never added. PayPal orders are charged WITHOUT taxes and shipping.
- **Fix**: In `paypal/create-order/route.ts`, calculate taxes and shipping server-side (same as Stripe checkout) and include them in the PayPal order `amount.breakdown`. In `paypal/capture/route.ts`, recalculate taxes and shipping from the database instead of trusting client values.

---

### E-03: PayPal Create-Order Does Not Include Taxes or Shipping in Amount
- **Severity**: CRITICAL
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/paypal/create-order/route.ts` (line 101)
- **Description**: `const serverTotal = serverSubtotal;` -- the comment says "Shipping/taxes handled by PayPal or added separately" but they are never added. The PayPal order is created with only the product subtotal. Customer is charged the subtotal WITHOUT taxes or shipping. This means PayPal orders lose ~15% revenue (tax) plus shipping fees.
- **Impact**: Direct financial loss on every PayPal order. For a $100 order in Quebec, the business loses $14.98 in taxes (TPS+TVQ) plus $9.99 in shipping = $24.97 per order.
- **Fix**: Add the same `calculateServerTaxes()` and `calculateServerShipping()` logic used in the Stripe checkout route. Include `tax_total` and `shipping` in the PayPal `amount.breakdown`.

---

### E-04: Promo Code Validation Ignores `firstOrderOnly`, `productIds`, and `categoryIds` Restrictions
- **Severity**: HIGH
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/api/promo/validate/route.ts` (entire file)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 174-193)
- **Description**: The PromoCode model has `firstOrderOnly Boolean`, `productIds String?`, and `categoryIds String?` fields (schema lines 1609-1611), but neither the validation endpoint nor the checkout route checks these constraints. A promo code restricted to first-time buyers or specific products will apply to ANY order.
- **Impact**: Promo codes designed for customer acquisition (first order only) can be reused by existing customers. Product-specific discounts (e.g., 50% off a specific peptide) can be applied to any product in the cart.
- **Fix**: In both `promo/validate/route.ts` and `create-checkout/route.ts`:
  1. Check `firstOrderOnly`: Query if the user has previous PAID orders
  2. Check `productIds`: Parse the JSON string and verify cart items include at least one matching product
  3. Check `categoryIds`: Similar check against product categories

---

### E-05: Promo Code Per-User Limit Check is Only in Webhook, Not at Checkout Time
- **Severity**: HIGH
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 174-193)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/webhook/route.ts` (lines 367-401)
- **Description**: At checkout time (create-checkout), the code checks `usageCount < usageLimit` (global limit) but never checks per-user usage. The per-user check (`maxUsesPerUser`) only happens AFTER payment in the webhook (line 372). A user who already used the code can still get a discounted checkout session, but their usage record will silently not be created. The discount is applied but the usage is not tracked.
- **Impact**: A user can use the same promo code unlimited times. The discount is applied to their Stripe session every time, but the webhook silently skips tracking when the per-user limit is reached. The `usageCount` global counter still won't increment, creating an inconsistency.
- **Fix**: Add per-user limit check in `create-checkout/route.ts` before applying the discount:
  ```typescript
  if (session?.user?.id) {
    const existingUsage = await prisma.promoCodeUsage.count({
      where: { promoCodeId: promo.id, userId: session.user.id },
    });
    if (existingUsage >= (promo.usageLimitPerUser || 1)) {
      // Reject the promo code
    }
  }
  ```

---

### E-06: Gift Card Balance Not Deducted on Checkout -- Client-Side Only
- **Severity**: HIGH
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/(shop)/checkout/page.tsx` (lines 167-198)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (entire file)
- **Description**: The checkout page allows applying a gift card (calls `/api/gift-cards/balance` to check balance), but the gift card discount is ONLY calculated client-side (line 180: `Math.min(data.balance, remainingTotal)`). The `create-checkout` and `create-intent` API routes have NO gift card handling at all. The gift card balance is never deducted from the database. The Stripe session is created for the full amount (minus promo only).
- **Impact**: Gift cards are decorative only. The customer sees a discount on the frontend, but is charged the full amount by Stripe/PayPal. Alternatively, if the frontend subtracts the gift card amount before sending to the API, the Stripe session would be created for a lower amount, but the gift card balance would never be deducted -- allowing unlimited reuse.
- **Fix**: Add gift card handling to `create-checkout/route.ts`:
  1. Accept `giftCardCode` in the request body
  2. Verify the gift card balance server-side
  3. Deduct from the Stripe amount (or apply as a credit)
  4. In the webhook, deduct the gift card balance atomically with a transaction
  5. Create a `GiftCardTransaction` audit trail

---

### E-07: Inventory Reservation Not Created for Products Without `formatId`
- **Severity**: HIGH
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 208-247)
- **Description**: The inventory reservation loop only creates reservations when `item.formatId` is present (line 210: `if (item.formatId)`). Products without formats (base products) are never reserved. If the business sells products without format variants, multiple customers can check out the same item simultaneously.
- **Impact**: Overselling for products without format variants. If all products currently use formats, this is lower risk, but any future base-product listing would be vulnerable.
- **Fix**: Also check and reserve stock for base products using the `product.stockQuantity` field (if tracked). Or enforce that all purchasable products must have at least one format.

---

### E-08: Stock Can Go Negative -- No Database-Level Constraint
- **Severity**: HIGH
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/prisma/schema.prisma` (line 1485)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/webhook/route.ts` (lines 298-304)
- **Description**: `stockQuantity Int @default(0)` -- the field is a plain integer with no `CHECK` constraint preventing negative values. The code uses `{ decrement: reservation.quantity }` which will happily go below zero. If a reservation is consumed but the stock was already reduced by another path (e.g., manual adjustment), stock becomes negative.
- **Impact**: Inventory reports show negative stock quantities, confusing warehouse operations. Overselling becomes possible if the check at reservation time passed but stock was adjusted between reservation and consumption.
- **Fix**: Add a PostgreSQL CHECK constraint via a migration:
  ```sql
  ALTER TABLE "ProductFormat" ADD CONSTRAINT stock_non_negative CHECK ("stockQuantity" >= 0);
  ```
  Also, use `UPDATE ... SET stockQuantity = stockQuantity - $1 WHERE stockQuantity >= $1` pattern or handle the case where decrement would go negative.

---

### E-09: Admin Order Status Update Has No Transition Validation
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/admin/orders/[id]/route.ts` (lines 157-243)
- **Description**: The PUT handler validates that `status` is one of the valid values, but does NOT validate the transition. An admin can set a DELIVERED order back to PENDING, or a CANCELLED order to SHIPPED. There is no state machine enforcing valid transitions (e.g., PENDING -> CONFIRMED -> PROCESSING -> SHIPPED -> DELIVERED).
- **Impact**: Invalid order states that confuse fulfillment, break email notifications (customer gets "shipped" notification for a cancelled order), and create incorrect accounting entries.
- **Fix**: Add a transition validation map:
  ```typescript
  const VALID_TRANSITIONS: Record<string, string[]> = {
    PENDING: ['CONFIRMED', 'CANCELLED'],
    CONFIRMED: ['PROCESSING', 'CANCELLED'],
    PROCESSING: ['SHIPPED', 'CANCELLED'],
    SHIPPED: ['DELIVERED'],
    DELIVERED: [], // Terminal state
    CANCELLED: [], // Terminal state
  };
  if (status && !VALID_TRANSITIONS[existingOrder.status]?.includes(status)) {
    return NextResponse.json({ error: `Cannot transition from ${existingOrder.status} to ${status}` }, { status: 400 });
  }
  ```

---

### E-10: Account Deletion is Not Implemented (GDPR Non-Compliance)
- **Severity**: HIGH
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/(shop)/account/settings/page.tsx` (lines 751-761)
- **Description**: The "Delete Account" button shows a `confirm()` dialog and then `alert(t('account.deletionRequested'))` -- but no API call is made. There is no `/api/user/delete` or `/api/account/delete` endpoint. No data is actually deleted. For a business serving customers in the EU/Canada (GDPR/PIPEDA), this is a compliance violation.
- **Impact**: Legal liability under GDPR (up to 4% of annual revenue) and PIPEDA. Customer personal data cannot be deleted on request.
- **Fix**: Implement a proper account deletion flow:
  1. Create `/api/account/delete` endpoint
  2. Anonymize or delete: name, email, phone, birthDate, addresses, payment info
  3. Keep order records with anonymized data (for tax/accounting)
  4. Cancel active subscriptions
  5. Revoke all sessions
  6. Send confirmation email
  7. Add 30-day grace period for recovery

---

### E-11: Partial Refund Does Not Restore Inventory
- **Severity**: MEDIUM
- **Files**:
  - `/Volumes/AI_Project/peptide-plus/src/app/api/admin/orders/[id]/route.ts` (lines 436-472)
  - `/Volumes/AI_Project/peptide-plus/src/app/api/payments/webhook/route.ts` (lines 545-576)
- **Description**: Both the admin refund handler and the Stripe webhook only restore inventory for FULL refunds (`if (isFullRefund)` on line 437 and `if (charge.amount_refunded === charge.amount)` on line 545). Partial refunds never restore stock, even if the partial refund corresponds to returning specific items. There is no mechanism to specify WHICH items are being refunded.
- **Impact**: If a customer returns 1 item from a 3-item order and gets a partial refund, the returned item's stock is never restored. Over time, this creates phantom inventory losses.
- **Fix**: Add item-level refund tracking. The admin refund endpoint should accept an optional `items` array specifying which items (and quantities) are being refunded. Restore stock for those specific items.

---

### E-12: Promo Code Usage Tracking Race Condition in PayPal Flow
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/paypal/capture/route.ts` (lines 228-248)
- **Description**: Promo code usage is incremented AFTER the order is created (line 230: `updateMany` on `usageCount`). Two concurrent PayPal captures with the same promo code could both pass the `usageCount < usageLimit` check at checkout time, then both increment the counter, exceeding the limit. Additionally, the PayPal flow does NOT check per-user limits at all (unlike the Stripe webhook which has a partial check).
- **Impact**: Promo codes can be used beyond their global usage limit. Per-user limits are not enforced at all for PayPal orders.
- **Fix**: Use an atomic increment with a conditional: `UPDATE "PromoCode" SET "usageCount" = "usageCount" + 1 WHERE code = $1 AND ("usageLimit" IS NULL OR "usageCount" < "usageLimit") RETURNING *`. If no row is returned, the code has been exhausted.

---

### E-13: Create-Intent Route Always Uses Quebec Taxes (Ignores User Location)
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-intent/route.ts` (lines 35-38)
- **Description**: The Payment Intent creation route hardcodes Quebec taxes: `tps = subtotal * 0.05; tvq = subtotal * 0.09975`. There is no location input from the client. Every customer pays Quebec taxes regardless of their actual province/country. Ontario customers should pay HST (13%), not TPS+TVQ (14.975%).
- **Impact**: Tax over-collection for provinces like Alberta (should be 5% GST only, but charged 14.975%), and under-collection for provinces like Ontario (should be 13% HST, but charged 14.975% TPS+TVQ -- actually over-collected here too). Tax remittance to CRA/Revenu Quebec will be incorrect.
- **Fix**: Accept the customer's province/country in the request body and use the same `calculateServerTaxes()` function from the checkout route.

---

### E-14: Cart Items Metadata Truncation Silently Loses Order Items
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 335-347)
- **Description**: If the JSON-serialized cart items exceed 490 characters, the code first truncates product names. If STILL over 490 chars, it sets `cartItemsStr = '[]'` (line 346). This empty array is stored in Stripe metadata and used by the webhook to create OrderItems. A large cart (many items or long names) will result in an order with NO items.
- **Impact**: Large orders ($500+ with many items) would be created with 0 order items. The customer is charged, but the order has no item details for fulfillment.
- **Fix**: Instead of storing cart items in Stripe metadata (limited to 500 chars per value), store them in a temporary database record (e.g., `CheckoutSession` table) keyed by `cartId`, and only pass `cartId` in Stripe metadata. The webhook then reads items from the database.

---

### E-15: Promo Discount Applied Proportionally Can Cause Rounding Errors
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 281-289)
- **Description**: When a promo discount is applied, it is distributed proportionally across all line items: `discountAmount = Math.round(originalAmount * discountRatio)`. Due to rounding, the sum of individual discounts may not equal the total discount. For example, 3 items at $33.33 with a $10 discount: each gets `Math.round(3333 * 0.1001)` = `Math.round(333.6)` = 334 cents, total = 1002 cents vs expected 1000 cents. The customer is overcharged by 2 cents.
- **Impact**: Small rounding discrepancies (1-5 cents) on orders with promo codes. Could accumulate to significant amounts over thousands of orders, and may cause reconciliation issues.
- **Fix**: Apply the discount to all items except the last, then compute the last item's discount as `totalDiscount - sumOfOtherDiscounts` to ensure exact match.

---

### E-16: Format Not Validated Against Product -- Cross-Product Format Attack
- **Severity**: HIGH
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/create-checkout/route.ts` (lines 135-145)
- **Description**: When a `formatId` is provided, the code looks up the format by ID alone (`prisma.productFormat.findUnique({ where: { id: item.formatId } })`). It does NOT verify that the format belongs to the specified product. A malicious client could send `productId: "expensive-peptide"` with `formatId: "cheap-format-from-another-product"` and be charged the cheap format's price while the order records the expensive product.
- **Impact**: Price manipulation. Customer pays a lower price by referencing a cheap format from a different product.
- **Fix**: Add `productId` to the format query:
  ```typescript
  const format = await prisma.productFormat.findFirst({
    where: { id: item.formatId, productId: item.productId },
  });
  ```

---

### E-17: PayPal Capture Does Not Verify Total Matches Expected Amount
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/paypal/capture/route.ts` (line 141)
- **Description**: After capturing the PayPal payment, the code uses PayPal's captured amount as the order total (line 141). This is good for preventing overcharge. However, it does NOT verify that the captured amount matches the server-calculated expected total (subtotal + tax + shipping - discount). If the PayPal order was created with a manipulated amount (see E-03), the capture will succeed for the wrong amount.
- **Impact**: Combined with E-03 (missing taxes/shipping in PayPal order), this means PayPal orders are consistently under-charged.
- **Fix**: After capture, verify that `capturedAmount >= expectedServerTotal`. If not, flag the order for manual review.

---

### E-18: Guest Orders Use Inconsistent User IDs
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/payments/webhook/route.ts` (line 242)
- **Description**: Guest orders store `userId` as `guest-${session.id}` (Stripe checkout session ID). This ID is not a real user in the database, meaning the `user` relation on the `Order` model cannot be resolved. Queries like `prisma.order.findMany({ include: { user: true } })` will fail or return null for guest orders.
- **Impact**: Admin dashboards and order lookups that join user data will crash or show incomplete information for guest orders. Email sending (line 486: `if (userId && userId !== 'guest')`) correctly skips non-logged-in users, but the stored `guest-*` userId is not `'guest'` -- it is `guest-cs_xxxx`. The condition fails, and the code tries to find a user with ID `guest-cs_xxxx`, which does not exist.
- **Fix**: Either: (a) Create a `Guest` model for anonymous orders, (b) Make `userId` nullable on `Order` and set it to null for guests, or (c) Store a consistent `'guest'` string and handle it throughout.

---

### E-19: Inventory Reservation TTL Depends on External Cron -- No Guarantee
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/cron/release-reservations/route.ts`
- **Description**: Expired inventory reservations are released by a cron job that must be configured externally (there is no built-in scheduler). If the cron job stops running (deployment issue, misconfiguration), expired reservations will never be released, and stock will remain perpetually "reserved."
- **Impact**: Abandoned carts permanently lock inventory, reducing available stock over time until manual intervention.
- **Fix**: In addition to the cron job, add a "check and release" step at the beginning of every `reserveStock()` call -- if the format has expired reservations, release them first. This provides a self-healing mechanism.

---

### E-20: Order Cancellation Restores Stock But Does Not Reverse Promo Code Usage
- **Severity**: MEDIUM
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/account/orders/[id]/cancel/route.ts` (entire file)
- **Description**: When a customer cancels an order, the stock is restored (lines 79-105) and the order is marked cancelled. However, if a promo code was used, the `usageCount` on the PromoCode is never decremented, and the `PromoCodeUsage` record is never removed. The promo code has effectively been "used up" without generating revenue.
- **Impact**: Promo codes with limited usage will be exhausted by cancelled orders. A malicious user could create and cancel orders to exhaust a promo code, making it unavailable to legitimate customers.
- **Fix**: In the cancellation transaction, decrement `usageCount` and delete or mark the `PromoCodeUsage` record:
  ```typescript
  if (order.promoCode) {
    await tx.promoCode.updateMany({
      where: { code: order.promoCode, usageCount: { gt: 0 } },
      data: { usageCount: { decrement: 1 } },
    });
    await tx.promoCodeUsage.deleteMany({
      where: { orderId: order.id },
    });
  }
  ```

---

### E-21: Gift Card Created Without Payment Verification
- **Severity**: HIGH
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/gift-cards/route.ts` (lines 26-90)
- **Description**: The POST endpoint creates a gift card with a balance immediately, without requiring any payment. The `amount` is accepted from the request body, validated only for range ($25-$1000), and a fully-funded gift card is created. There is no Stripe/PayPal integration to charge for the gift card purchase.
- **Impact**: Anyone can create unlimited gift cards worth up to $1000 each without paying. Even if gift card redemption at checkout is not fully implemented (see E-06), the gift card records exist and could be exploited once the feature is connected.
- **Fix**: Gift card creation should follow the same payment flow as products:
  1. Create a Stripe Checkout session for the gift card amount
  2. Only create the gift card record in the webhook after payment succeeds
  3. Or use Stripe's native gift card / stored value functionality

---

### E-22: User Profile Locale Validation Only Allows 'fr' and 'en' but System Supports 22 Locales
- **Severity**: LOW
- **File**: `/Volumes/AI_Project/peptide-plus/src/app/api/user/profile/route.ts` (line 73)
- **Description**: `if (locale && !['fr', 'en'].includes(locale))` -- the profile update only accepts 'fr' and 'en' as valid locales. But the i18n system supports 22 locales (ar, de, es, hi, ko, zh, etc.). Users who browse in other languages cannot save their locale preference.
- **Impact**: Non-French/English speaking users lose their language preference between sessions. The site defaults back to French on every visit.
- **Fix**: Use the full list of supported locales from the i18n configuration:
  ```typescript
  const SUPPORTED_LOCALES = ['en', 'fr', 'ar', 'ar-dz', 'ar-lb', 'ar-ma', 'de', 'es', 'gcr', 'hi', 'ht', 'it', 'ko', 'pa', 'pl', 'pt', 'ru', 'sv', 'ta', 'tl', 'vi', 'zh'];
  if (locale && !SUPPORTED_LOCALES.includes(locale)) { ... }
  ```

---

## Summary Table

| ID | Severity | Category | Description |
|----|----------|----------|-------------|
| E-01 | CRITICAL | Payment | Order number race condition (duplicate IDs on concurrent webhooks) |
| E-02 | CRITICAL | Payment/Tax | PayPal capture trusts client-sent tax/shipping |
| E-03 | CRITICAL | Payment/Tax | PayPal create-order omits taxes and shipping entirely |
| E-04 | HIGH | Promo Codes | `firstOrderOnly`, `productIds`, `categoryIds` restrictions ignored |
| E-05 | HIGH | Promo Codes | Per-user limit only checked post-payment, not at checkout |
| E-06 | HIGH | Gift Cards | Gift card discount is client-side only, balance never deducted |
| E-07 | HIGH | Inventory | No reservation for products without formatId |
| E-08 | HIGH | Inventory | Stock can go negative (no DB constraint) |
| E-09 | MEDIUM | Orders | No status transition validation (admin can set any status) |
| E-10 | HIGH | GDPR | Account deletion not implemented (button is a no-op) |
| E-11 | MEDIUM | Inventory | Partial refunds do not restore inventory |
| E-12 | MEDIUM | Promo Codes | Usage tracking race condition in PayPal flow |
| E-13 | MEDIUM | Tax | create-intent always uses Quebec taxes |
| E-14 | MEDIUM | Orders | Cart metadata truncation loses items on large orders |
| E-15 | MEDIUM | Pricing | Promo discount rounding distributes unevenly |
| E-16 | HIGH | Pricing | Format not validated against product (cross-product attack) |
| E-17 | MEDIUM | Payment | PayPal capture does not verify expected total |
| E-18 | MEDIUM | Data | Guest orders use non-existent user IDs |
| E-19 | MEDIUM | Inventory | Reservation TTL depends on external cron with no fallback |
| E-20 | MEDIUM | Promo Codes | Cancelled orders don't reverse promo code usage count |
| E-21 | HIGH | Gift Cards | Gift cards created without payment |
| E-22 | LOW | i18n | Profile locale validation too restrictive (2 vs 22 locales) |

---

## Priority Remediation Order

### Immediate (Fix before next deployment)
1. **E-03** -- PayPal missing taxes/shipping (direct revenue loss on every PayPal order)
2. **E-02** -- PayPal capture trusting client taxes
3. **E-21** -- Gift cards created without payment
4. **E-16** -- Cross-product format price manipulation
5. **E-01** -- Order number race condition

### High Priority (Fix within 1 week)
6. **E-06** -- Gift card balance never deducted
7. **E-10** -- GDPR account deletion
8. **E-04** -- Promo code restriction bypass
9. **E-05** -- Per-user promo limit bypass
10. **E-08** -- Stock negative constraint

### Medium Priority (Fix within 1 month)
11. **E-09** -- Status transition validation
12. **E-14** -- Cart metadata truncation
13. **E-11** -- Partial refund inventory
14. **E-12** -- PayPal promo race condition
15. **E-13** -- Create-intent hardcoded taxes
16. **E-18** -- Guest user ID inconsistency
17. **E-20** -- Promo usage on cancelled orders
18. **E-07** -- Base product reservation

### Low Priority
19. **E-15** -- Rounding error
20. **E-17** -- PayPal amount verification
21. **E-19** -- Cron dependency
22. **E-22** -- Locale validation

---

*Report generated by Claude Opus 4.6 on 2026-02-19*
