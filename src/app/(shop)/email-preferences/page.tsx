export const dynamic = 'force-dynamic';

/**
 * Email Preference Center Page
 *
 * Server Component that verifies the JWT token from the URL,
 * fetches current preferences, and renders the client form.
 *
 * URL: /email-preferences?token=<JWT>
 *
 * This page works WITHOUT authentication - users access it via
 * a signed link embedded in marketing/newsletter emails.
 *
 * Generated by: src/lib/email/unsubscribe.ts -> generatePreferenceCenterUrl()
 */

import { Metadata } from 'next';
import * as jose from 'jose';
import { prisma } from '@/lib/db';
import PreferenceForm from './PreferenceForm';
import type { EmailPreferences } from './PreferenceForm';
import Link from 'next/link';

export const metadata: Metadata = {
  title: 'Email Preferences - BioCycle Peptides',
  description: 'Manage your email communication preferences for BioCycle Peptides.',
  robots: { index: false, follow: false },
};

// ---------------------------------------------------------------------------
// Token verification
// ---------------------------------------------------------------------------

function getSecret() {
  const secret = process.env.UNSUBSCRIBE_SECRET || process.env.NEXTAUTH_SECRET;
  if (!secret) {
    throw new Error('UNSUBSCRIBE_SECRET or NEXTAUTH_SECRET must be configured');
  }
  return new TextEncoder().encode(secret);
}

interface TokenPayload {
  email: string;
  category: string;
  userId?: string;
}

async function verifyToken(token: string): Promise<TokenPayload | null> {
  try {
    const { payload } = await jose.jwtVerify(token, getSecret());
    return payload as unknown as TokenPayload;
  } catch {
    return null;
  }
}

function maskEmail(email: string): string {
  const [local, domain] = email.split('@');
  if (!local || !domain) return '***@***';
  if (local.length <= 2) {
    return `${local[0]}${'*'.repeat(Math.max(local.length - 1, 1))}@${domain}`;
  }
  return `${local[0]}${'*'.repeat(local.length - 2)}${local[local.length - 1]}@${domain}`;
}

// ---------------------------------------------------------------------------
// Error Page (static, no client-side JS needed)
// ---------------------------------------------------------------------------

function ErrorPage({ type }: { type: 'missing' | 'invalid' | 'expired' | 'error' }) {
  const messages: Record<string, { title: string; description: string; icon: string }> = {
    missing: {
      title: 'Missing Link Token',
      description:
        'This page requires a valid token. Please use the "manage preferences" link from one of our emails.',
      icon: 'M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.964-.833-2.732 0L4.082 16.5c-.77.833.192 2.5 1.732 2.5z',
    },
    invalid: {
      title: 'Invalid Link',
      description:
        'This link is invalid or has been tampered with. Please use a recent "manage preferences" link from one of our emails.',
      icon: 'M18.364 18.364A9 9 0 005.636 5.636m12.728 12.728A9 9 0 015.636 5.636m12.728 12.728L5.636 5.636',
    },
    expired: {
      title: 'Link Expired',
      description:
        'This link has expired. Please use a more recent "manage preferences" link from one of our emails.',
      icon: 'M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z',
    },
    error: {
      title: 'Something Went Wrong',
      description:
        'An error occurred while loading your preferences. Please try again later or contact support.',
      icon: 'M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z',
    },
  };

  const msg = messages[type] || messages.error;

  return (
    <div className="min-h-screen bg-gray-50 flex items-center justify-center px-4">
      <div className="max-w-md w-full text-center">
        <div className="w-16 h-16 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-6">
          <svg
            className="w-8 h-8 text-orange-600"
            fill="none"
            stroke="currentColor"
            viewBox="0 0 24 24"
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d={msg.icon}
            />
          </svg>
        </div>
        <h1 className="text-2xl font-bold text-neutral-900 mb-3">{msg.title}</h1>
        <p className="text-neutral-600 mb-8">{msg.description}</p>
        <Link
          href="/"
          className="inline-flex items-center gap-2 px-6 py-3 bg-orange-500 text-white rounded-lg font-medium hover:bg-orange-600 transition-colors"
        >
          <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M10 19l-7-7m0 0l7-7m-7 7h18"
            />
          </svg>
          Back to BioCycle Peptides
        </Link>
      </div>
    </div>
  );
}

// ---------------------------------------------------------------------------
// Page Component (Server)
// ---------------------------------------------------------------------------

interface PageProps {
  searchParams: Promise<{ [key: string]: string | string[] | undefined }>;
}

export default async function EmailPreferencesPage({ searchParams }: PageProps) {
  const params = await searchParams;
  const token = typeof params.token === 'string' ? params.token : undefined;

  // 1. Token must be present
  if (!token) {
    return <ErrorPage type="missing" />;
  }

  // 2. Verify JWT
  const payload = await verifyToken(token);
  if (!payload) {
    return <ErrorPage type="invalid" />;
  }

  // 3. Fetch current preferences from database
  const email = payload.email.toLowerCase().trim();

  let initialPreferences: EmailPreferences;
  try {
    const [newsletterSub, mailingListSub, notificationPref] = await Promise.all([
      prisma.newsletterSubscriber.findUnique({ where: { email } }).catch(() => null),
      prisma.mailingListSubscriber
        .findUnique({
          where: { email },
          include: { preferences: true },
        })
        .catch(() => null),
      payload.userId
        ? prisma.notificationPreference
            .findUnique({ where: { userId: payload.userId } })
            .catch(() => null)
        : Promise.resolve(null),
    ]);

    // Build consolidated preference state
    initialPreferences = {
      marketing:
        notificationPref?.promotions ??
        (mailingListSub?.status === 'ACTIVE'
          ? true
          : mailingListSub
            ? false
            : true),
      newsletter: notificationPref?.newsletter ?? newsletterSub?.isActive ?? true,
      weeklyDigest: notificationPref?.weeklyDigest ?? false,
      priceDrops:
        notificationPref?.priceDrops ??
        (mailingListSub?.preferences?.find((p) => p.category === 'specials')?.isEnabled ?? false),
      stockAlerts: notificationPref?.stockAlerts ?? true,
      productReviews: notificationPref?.productReviews ?? false,
      birthdayOffers: notificationPref?.birthdayOffers ?? true,
      loyaltyUpdates: notificationPref?.loyaltyUpdates ?? true,
    };

    // Override with mailing list topic-level preferences if available
    if (mailingListSub?.preferences) {
      for (const pref of mailingListSub.preferences) {
        if (pref.category === 'promotions' && !pref.isEnabled) {
          initialPreferences.marketing = false;
        }
        if (pref.category === 'new_products' && !pref.isEnabled) {
          initialPreferences.priceDrops = false;
        }
      }
    }
  } catch (error) {
    console.error('[email-preferences] Failed to fetch preferences:', error);
    return <ErrorPage type="error" />;
  }

  return (
    <PreferenceForm
      token={token}
      email={maskEmail(email)}
      initialPreferences={initialPreferences}
      hasAccount={!!payload.userId}
    />
  );
}
